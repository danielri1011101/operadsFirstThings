module PermFile (someDigits, permuteList, permuteNrs) where -- Permute file

import System.Random

someDigits :: IO [Int]
someDigits = do
  g <- getStdGen
  let r_nrs = randoms g :: [Int]
  let r_nrs'= take 20 r_nrs
  let ds = map (flip mod $ 10) r_nrs'
  putStrLn $ show ds
  return ds

permuteList :: RandomGen g => [a] -> g -> [a]
permuteList xs r_g = p_map (pmt r_g n) xs
  where
    p_map :: [Int] -> [a] -> [a] 
    p_map ns xs = foldr ((:) . (xs!!)) [] ns
    (pmt, n) = (permuteNrs, length xs)

permuteNrs :: RandomGen g => g -> Int -> [Int]
permuteNrs r_g n
  | n <= 0 = []
  | otherwise = shuffle [1..n] $ map (+1) $ rRs r_g n
      where
        rRs = randomResidues

-- @[a]$1 Finite list without repetitions
-- @[a]$2 Random infinite list with @[a]$1 as a subsequence
-- @val The first occurence of @[a]$1 < @[a]$2
shuffle :: Eq a => [a] -> [a] -> [a]
shuffle _ [] = []
shuffle xs i_l@(h:yys) = shfHelp xs i_l [] $ length xs
  where
    shfHelp _ [] q _ = q
    shfHelp _ _ q 0 = q
    shfHelp xs (h:yys) q n
      | n < 0 = q
      | h `elem` xs && (not $ h `elem` q) = shfHelp xs yys (h:q) (n-1)
      | otherwise = shfHelp xs yys q n
        
-- Maps ''take residue mod n'' over the @[Int] generated by @g.
randomResidues :: RandomGen g => g -> Int -> [Int]
randomResidues r_g n
  | n < 1 = []
  | otherwise = map (flip mod $ n) r_nrs
      where
        r_nrs = randoms r_g :: [Int]
